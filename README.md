# Simple-Paxos
A Simple-Paxos test in GoLang


我们不是要实现一个运行在生产环境中的算法’我们需要对算法做＿些简化’否则会陷入
许多细节和健壮性的讨论’让代码变得非常长°我们要实现的Paxos算法有多简单呢?我们不
持久化存储任何变量,也不使用互斥锁来保证数据并发的正确性,旨在使用最简化的代码实现
BasicPaxos算法的流程°我们会用到Go语言自带的RPC包来实现通信（但整个程序仍运行在
同一台计算机中）’同时使用Go语言的单元测试来验证算法是否正确°
需要说明的是’我们实现的算法完全按照Lamport的论文中描述的流程,
不做任何优化。


有兴趣的同学可以一起学习，慢慢迭代升级～

## 主要过程

入口为main函数定义提案值（value）和学习者（learner）、接受者（acceptor）


提案者（proposer）发起提案


主要过程是由两个阶段Prepare 和 Accept 组成


每个阶段都有A和B两个过程

### **第一阶段（Prepare）**
**过程A**

向所有的接受者（acceptor）携带提案编号（Number）广播消息
这里也可以选择向超过半数的接受者广播，具体原因不再赘述

**过程B：**

接受者（acceptor）收到消息后，给提案者（proposer）响应

如果提案者（proposer）的编号小于接受者所见过的最大提案编号 则直接拒绝此次提案

如果大于，首先承诺不在接受提案编号比其小的提案，如果这个接受者接受者（acceptor）已经接受了一个提案，则将接受的提案值和提案编号一起返回

--

**前提： 第一阶段广播出去的消息得到半数以上的acceptor的响应后开始第二阶段**

--

### **第二阶段（Accept）**
**过程A**


向所有的接受者（acceptor）携带提案编号（Number）和提案值（value)广播消息

这个时候如果proposer有Value的话就携带（可能是第一阶段返回的），如果没有的话可以**自定义Value**


**过程B：**

首先确认提案编号是自己见过最大的提案编号，否则resp-nil
如果是的话将提案编号和提案值记录 并且 同时 广播给学习者


这样接受提案的过程就算完成了

接受提案不同于批准提案，一个取决于单个acceptor，另一个取决于半数以上的acceptor

### **学习者（Chosen）**

上述逻辑都是提议者和接受者在交互’那么学习者怎么知道一个提案被批准了呢?在论文
23节“LeamjngaChosenValue”中提到,最简单的方案是接受者接受—个提案后’将接受的提
案广播给学习者,这＿步我们在接受者代码逻辑中已经实现°—旦学习者收到超过半数的接受者发来的同—个已接受提案’就知道这个提案被批准了。


具体逻辑可以看Leaner的代码

主要为 更新提案信息  -- chosen时计数选出超过半数的提案



